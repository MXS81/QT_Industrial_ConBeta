# 配方管理系统重构说明文档

## 重构概述

根据《配方管理&全局参数设置.csv》文档要求，对磁浮控制系统的配方管理模块进行了全面重构。本次重构主要目的是实现从保持寄存器[36]开始的标准化Modbus写入，并调整数据结构以符合下位机通信协议。

## 重构内容详细说明

### 1. 数据结构重构

#### 1.1 StationRecipe结构体更新（recipemanager.h）

**原始数据结构：**
```cpp
struct StationRecipe {
    quint16 stationNo;          // 工位NO
    quint16 taskId;             // 任务ID  
    quint16 segmentNo;          // 所属路段号
    float segmentPosition;      // 路段位置（浮点数）
    float segmentSpeed;         // 路段速度（浮点数）
    float startPosition;        // 起始位置（浮点数）
    float endPosition;          // 终止位置（浮点数）
    float arrivalDelay;         // 到位延时（浮点数）
    FerryPosition ferryPos;     // 摆渡位置
    bool stationMask;           // 工位屏蔽
    quint16 recipeId;           // 配方ID
};
```

**重构后数据结构：**
```cpp
struct StationRecipe {
    // 8位参数（打包到16位寄存器）
    quint8 stationNo;           // 工位NO（bit0，索引0）
    quint8 taskId;              // 任务ID（bit1，索引0）
    quint8 segmentNo;           // 所属路段号（bit0，索引1）
    quint8 nextStationId;       // 目标工位号（bit1，索引1）NEW!
    
    // 16位无符号整数参数（每个占1个寄存器）
    quint16 segmentPosition;    // 路段位置（索引2）
    quint16 segmentSpeed;       // 路段速度（索引3）
    quint16 startPosition;      // 起始位置（索引4）
    quint16 endPosition;        // 终止位置（索引5）
    quint16 arrivalDelay;       // 到位延时（索引6）
    
    // 枚举与布尔（打包到16位寄存器）
    FerryPosition ferryPos;     // 摆渡位置（bit0，索引7）
    bool stationMask;           // 工位屏蔽（bit1，索引7）
    
    quint16 recipeId;           // 配方ID（上位机使用）
};
```

**主要变化：**
- 添加了 `nextStationId`（目标工位号）参数
- 所有浮点数参数改为16位无符号整数
- 数据类型从 `quint16` 改为 `quint8` 用于需要打包的参数
- 到位延时单位从秒改为毫秒

### 2. Modbus寄存器映射重构

#### 2.1 寄存器地址更新

**原始映射：**
```cpp
static const int BASE_ADDR = 0x0100;  // 配方数据基址
static const int STATION_SIZE = 15;    // 每个工位占用15个寄存器
```

**重构后映射（按CSV文档要求）：**
```cpp
static const int STATION_COUNT_ADDR = 0x0023;  // 寄存器[35]：工位总数
static const int BASE_ADDR = 0x0024;           // 寄存器[36]：配方数据基址  
static const int STATION_SIZE = 8;             // 每个工位占用8个寄存器
```

#### 2.2 寄存器偏移定义

**重构后寄存器布局（每工位8个寄存器）：**
```cpp
enum RegisterOffset {
    OFFSET_STATION_TASK = 0,    // 工位NO(bit0) + 任务ID(bit1)
    OFFSET_SEGMENT_NEXT = 1,    // 路段号(bit0) + 目标工位号(bit1)
    OFFSET_SEG_POSITION = 2,    // 路段位置
    OFFSET_SEG_SPEED = 3,       // 路段速度
    OFFSET_START_POSITION = 4,  // 起始位置
    OFFSET_END_POSITION = 5,    // 终止位置
    OFFSET_ARRIVAL_DELAY = 6,   // 到位延时
    OFFSET_FERRY_MASK = 7       // 摆渡位置(bit0) + 工位屏蔽(bit1)
};
```

### 3. Modbus通信协议实现

#### 3.1 数据打包方法

新增了数据打包/解包方法：
```cpp
// 将两个8位值合并为一个16位寄存器
quint16 packTwoBytes(quint8 lowByte, quint8 highByte) const;
void unpackTwoBytes(quint16 value, quint8& lowByte, quint8& highByte) const;
```

#### 3.2 Modbus写入实现

新增了标准化写入方法：
```cpp
bool writeStationToModbus(int stationIndex, const StationRecipe& recipe);
bool writeStationCountToModbus(int stationCount);
```

**写入流程：**
1. 寄存器[35] ← 工位总数
2. 寄存器[36+i*8] ← 第i个工位的8个寄存器数据

#### 3.3 具体写入示例

以工位1为例，数据写入到寄存器[36-43]：
```cpp
// 寄存器36: 工位NO(1) + 任务ID(1) = 0x0101
// 寄存器37: 路段号(1) + 目标工位号(2) = 0x0201  
// 寄存器38: 路段位置 = 188
// 寄存器39: 路段速度 = 1000
// 寄存器40: 起始位置 = 0
// 寄存器41: 终止位置 = 100
// 寄存器42: 到位延时 = 500
// 寄存器43: 摆渡位置(1) + 工位屏蔽(0) = 0x0001
```

### 4. 用户界面重构

#### 4.1 控件类型更新（recipewidget.h）

**原始控件定义：**
```cpp
QDoubleSpinBox* m_segmentPosSpin;     // 浮点数控件
QDoubleSpinBox* m_segmentSpeedSpin;   // 浮点数控件  
QDoubleSpinBox* m_startPosSpin;       // 浮点数控件
QDoubleSpinBox* m_endPosSpin;         // 浮点数控件
QDoubleSpinBox* m_arrivalDelaySpin;   // 浮点数控件
```

**重构后控件定义：**
```cpp
QSpinBox* m_nextStationSpin;        // 新增：目标工位号
QSpinBox* m_segmentPosSpin;         // 改为整数控件
QSpinBox* m_segmentSpeedSpin;       // 改为整数控件
QSpinBox* m_startPosSpin;           // 改为整数控件
QSpinBox* m_endPosSpin;             // 改为整数控件
QSpinBox* m_arrivalDelaySpin;       // 改为整数控件
```

#### 4.2 界面布局优化

**控件参数范围更新：**
- 8位参数：范围 1-255
- 16位参数：范围 0-65535
- 到位延时单位：从 "s" 改为 "ms"

#### 4.3 当前工位显示优化

按要求移除了"当前工位"显示，并将"复位当前工位"按钮移到配方管理区域：

**重构前：**
```cpp
// 显示当前工位选择器
m_controlLayout->addWidget(new QLabel("当前工位:"));
m_controlLayout->addWidget(m_currentStationSpin);
// 复位按钮在控制区域
m_controlLayout->addWidget(m_resetBtn);
```

**重构后：**
```cpp
// 隐藏当前工位显示
m_currentStationSpin->setVisible(false);
// 复位按钮移至配方管理区域
m_recipeManagementLayout->addWidget(m_resetBtn);
```

### 5. 数据转换方法重构

#### 5.1 移除浮点数转换

删除了原有的浮点数转换方法：
```cpp
// 已删除
void floatToRegisters(float value, quint16& high, quint16& low);
float registersToFloat(quint16 high, quint16 low);
```

#### 5.2 数据获取/设置方法更新

**getRecipeFromControls()方法重构：**
```cpp
// 重构前
recipe.segmentPosition = static_cast<float>(m_segmentPosSpin->value());
recipe.taskId = m_taskIdSpin->value();  // quint16

// 重构后  
recipe.segmentPosition = static_cast<quint16>(m_segmentPosSpin->value());
recipe.taskId = static_cast<quint8>(m_taskIdSpin->value());  // quint8
recipe.nextStationId = static_cast<quint8>(m_nextStationSpin->value());  // 新增
```

### 6. 工位配置初始化

#### 6.1 默认配置更新

**重构后的10工位默认配置：**
```cpp
for (int i = 0; i < 10; ++i) {
    StationRecipe recipe;
    recipe.stationNo = i + 1;
    recipe.segmentNo = i + 1;  
    recipe.nextStationId = (i < 9) ? i + 2 : 1;  // 下一工位形成环路
    recipe.segmentPosition = 188 + i * 120;      // 整数位置
    recipe.segmentSpeed = 1000;                  // 默认速度
    recipe.arrivalDelay = 500;                   // 500ms延时
    
    // 任务ID按工艺分配
    if (i < 2) recipe.taskId = 1;      // S1-S2: 绕线
    else if (i < 4) recipe.taskId = 2;  // S3-S4: 点胶  
    else if (i < 6) recipe.taskId = 3;  // S5-S6: 焊接
    else if (i < 8) recipe.taskId = 4;  // S7-S8: 注塑
    else recipe.taskId = 5;            // S9-S10: 下料
}
```

### 7. 保存流程优化

#### 7.1 saveAllRecipes方法增强

**重构后保存流程：**
```cpp
bool RecipeManager::saveAllRecipes() {
    // 1. 首先写入工位总数到寄存器[35]
    if (!writeStationCountToModbus(m_stations.size())) return false;
    
    // 2. 然后从寄存器[36]开始写入所有工位配方数据  
    for (int i = 0; i < m_stations.size(); ++i) {
        if (!saveRecipe(i, m_stations[i])) return false;
    }
    
    return true;
}
```

## 重构效果总结

### 改进点

1. **标准化通信协议**: 严格按照CSV文档规范实现Modbus寄存器映射
2. **存储效率提升**: 每工位从15个寄存器减少到8个寄存器，节省47%存储空间
3. **数据类型优化**: 使用整数替代浮点数，提高传输可靠性
4. **功能完整性**: 新增目标工位号参数，支持完整的工位流转逻辑
5. **界面优化**: 移除冗余显示，将复位功能集成到配方管理区域

### 技术优势

1. **高效打包**: 通过bit位打包，一个16位寄存器存储两个8位参数
2. **错误处理**: 完善的Modbus通信错误处理机制
3. **数据一致性**: 上位机界面与下位机寄存器严格对应
4. **扩展性好**: 预留了扩展接口，支持未来功能增强

### 兼容性说明

- **向前兼容**: 保留了原有的配方文件加载/保存功能
- **数据迁移**: 现有配方数据可通过类型转换自动适配
- **界面保持**: 主要界面布局保持不变，用户操作习惯无需改变

## 测试建议

1. **单工位测试**: 验证单个工位参数的读写正确性
2. **批量测试**: 验证10个工位的批量写入功能
3. **边界测试**: 验证参数范围边界值的处理
4. **通信测试**: 验证与下位机的Modbus通信稳定性
5. **界面测试**: 验证用户界面的响应和数据同步

